#### 为什么存在跨域问题

浏览器处于安全考虑，有同源策略，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败（请求已经发送出去了，但浏览器作了拦截）

具体过程如下

- 客户端直接向第三方服务器发起请求时，第三方服务器为了安全起见不会向所有网址开启跨域，这时就需要自己的服务器作代理
- 客户端向自己的服务器发出请求，自己的服务器开启跨域
- 由于服务端没有同源策略的限制，自己的服务器收到请求后，向第三方服务器发出相应的请求
- 第三方服务器收到请求后，响应给自己的服务器
- 自己的服务器再响应给客户端

![](https://user-gold-cdn.xitu.io/2019/11/14/16e689aac687050b?w=964&h=526&f=png&s=16553)

#### cors

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS，该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

```js
res.writeHeader("Access-Control-Allow-Origin":"*")
```

expree框架中可以引入cors中间件

```js
const express=require("express")
const app=express()
const cors=require("cors")
app.use(cors())
```

#### jsonp

利用script标签没有跨域限制的漏洞，当需要通讯时通过script标签指向一个需要访问的地址并提供一个回调函数来接收数据

前端处理

```js
var script=document.createElement("script")
script.src="http://localhost:3000?a=4&b=4&cb=fn"
document.body.appendChild(script)
function fn(a,b){
    console.log(a+b)
}
```

服务端处理

```js
var http=require("http")
var querystring=require("queryString")
var sever=http.createServer(function(req,res){
    req.on("data",function(){})
    req.on("end",function(){
        var obj=querystring.parse(req.url.split("?")[1])
        res.writeHeader("Access-Control-Allow-Origin":"*")
        res.send(obj.cb+"("+obj.a","+obj.b+")")
        res.end()
    })
})
sever.listen(3000,"localhost",()=>{
    console.log("server start")
})
```

> 使用简单且兼容性不错，但是只限于 get 请求

#### webSocket

一种在单个TCP连接上进行的全双工通讯协议，只需要一次握手就可以建立长久联系，可进行双向的数据传输

> ajax一次握手后就断开连接

客户端发出建立webSocket连接的请求，连接建立后，通过send方法向服务器发送数据，最后侦听massage事件接收服务器响应

```js
let socket=new webSocket("ws://www.17xc.net:6785")//webSocket协议
socket.onopen=function(){
    if(socket.readyState==1){
        socket.send()
    }
}
socket.onmassage=function(res){
    console.log(res.data)
}
```

#### document.domain

只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com，给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域

#### postMessage

用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
//发送消息
window.parent.postMessage('message', 'http://test.com')
//接收消息
var mc = new MessageChannel()
mc.addEventListener('message', event => {
  var origin = event.origin || event.originalEvent.origin
  if (origin === 'http://test.com') {
    console.log('验证通过')
  }
})
```

#### webpack跨域代理

代码如下

```js
let path=require('path');

module.exports={
    mode: "development",//有两种模式：production(生产环境:代码压缩)/development(开发环境:代码不压缩)
    entry:'./src/index.js',//入口文件
    output: {
        filename: "bundle.js",//打包后的文件名
        path: path.resolve('dist')//路径必须是一个绝对路径
    },
    devServer: {//开启服务器配置
        port:8080,//端口，
        host:”localhost”,//ip地址:localhost本地，0.0.0.0可以访问网络地址
        progress:true,//开启进度条
        contentBase:"./build",//默认打开目录
        open:true, //自动打开浏览器
        compress:true,//启动gzp压缩
        proxy: {
            '/api': {
                target: 'http://10.0.193.147:8080',
                changeOrigin: true, //是否跨域
                pathRewrite: {
                    '^/api': '' //检测以/api开头的地址才作跨域处理
                }
            }
        }
    }
}
```
