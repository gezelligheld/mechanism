#### 进程和线程

- 进程，cpu资源分配的最小单位，系统会给它分配内存，不同进程之间也可以通信，不过代价较大

- 线程，cpu调度的最小单位，是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程

#### 浏览器中的进程

浏览器是多进程的，常见进程如下

- Browser进程：浏览器主进程，负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；网络资源的管理，下载等

- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

- GPU进程：最多一个，用于3D绘制等

- 渲染进程，默认每个Tab页面一个进程，负责页面渲染，脚本执行，事件处理等

相比于单进程，多进程有以下优点

- 避免单个页面崩溃影响整个浏览器

- 避免单个插件崩溃影响整个浏览器

- ...

#### 渲染进程

浏览器的渲染进程是多线程的，常见的线程如下

- GUI渲染线程

    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等

    - 页面重绘或者重排时该线程就会执行

- JS引擎线程

    - 负责处理Javascript脚本程序

    - 一个渲染进程中只有一个JS引擎线程

- 事件触发线程

    - 用来控制事件循环

    - 当JS引擎执行代码块如setTimeOut、鼠标点击、AJAX异步请求等时，会将对应任务添加到事件线程中

    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理

- 定时触发器线程

    - setInterval与setTimeout所在线程，所以浏览器定时计数器并不是由JavaScript引擎计数的，因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确

    - 计时完毕后，添加到事件队列中，等待JS引擎空闲后执行

- 异步http请求线程

    - XMLHttpRequest连接后通过浏览器新开一个线程请求

    - 如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行

##### Browser进程和渲染进程的通信过程

流程如下

1. Browser进程收到用户请求，首先需要获取页面内容，随后将该任务传递给渲染进程

2. 渲染进程接收到消息后，交给GUI渲染线程，然后开始渲染

    1. 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染，可能会有JS线程操作DOM

    2. 最后渲染进程将结果传递给Browser进程

3. Browser进程接收到结果并将结果绘制出来

##### GUI渲染线程与JS引擎线程互斥

由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面，那么渲染线程前后获得的元素数据就可能不一致了，因此为了防止渲染出现不可预期的结果

当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行

如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致卡顿

##### WebWorker线程

Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法，线程可以执行任务而不干扰用户界面。一个worker是使用一个构造函数创建的一个对象运行一个命名的JavaScript文件，这个文件包含将在工作线程中运行的代码。worker运行在另一个不同于window的全局上下文中

简言之

- 创建Worker时，JS引擎向浏览器申请开一个子线程

- JS引擎线程与worker线程间可以通过特定的方式通信

WebWorker和SharedWorker区别如下

- WebWorker只属于某个页面，不会和其他页面的渲染进程共享，所以每个渲染进程都会创建一个新的线程来运行web worker中的js代码

- SharedWorker是浏览器所有页面共享的，可以为多个渲染进程共享使用，所以浏览器会单独为SharedWorker创建一个进程来执行SharedWorker中的js代码

> 有且只有一个SharedWorker进程，不管创建多少次

参考文档

1. [从浏览器的多进程到js的单进程](https://segmentfault.com/a/1190000012925872)