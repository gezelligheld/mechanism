#### 渲染流程

大致流程如下

1. 解析html建立dom树

2. 解析css构建render树

3. 布局render树，负责各元素尺寸、位置的计算

4. 绘制render树，绘制页面像素信息

5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成，最后显示到屏幕上

##### 构建DOM树

首先浏览器渲染进程的主线程将html解析为DOM树

##### 样式计算

根据css继承规则和层叠规则计算每个节点的样式，然后结合DOM树合并为render树

##### 布局阶段

DOM树和样式构建完成后，需要计算DOM树中可见元素的几何信息

1. 创建布局树（layout tree），遍历DOM所有可见节点，将其添加到布局树中，如display: none的元素会被忽略

2. 布局计算，生成layout tree后，计算每个节点的坐标位置

##### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）

渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层

满足下面两点中任意一点的元素创建新的图层

1. 拥有层叠上下文属性的元素会被提升为单独的一层

- 根元素html
- position 值为 absolute 或 relative且 z-index 值不为 auto 的元素
- position 值为 fixed 或 sticky 的元素
- flex 容器的子元素，且 z-index 值不为 auto
- grid 容器的子元素，且 z-index 值不为 auto
- opacity 属性值小于 1 的元素

2. 需要剪裁的地方也会被创建为图层

如果把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层

##### 图层绘制

layer tree构建完成后，渲染引擎将每个图层拆分成小的绘制指令，再将这些指令按顺序组成待绘制列表

![image](https://pic1.zhimg.com/80/v2-f618a42e7fcf7e565513376f099aa640_1440w.jpg)

至此，上述操作均在渲染进程的GUI渲染线程中完成

##### 栅格化（raster）

当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，合成线程会将图层划分为图块（tile），按照视口（viewport）附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图

图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的

![image](https://pic4.zhimg.com/80/v2-ef4066203badce5e880732234ec4a8cf_1440w.jpg)

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中，这就涉及到与GPU进程的跨进程操作

![image](https://pic1.zhimg.com/80/v2-87d0635f049e8a572932607baa45e640_1440w.jpg)

##### 显示

当所有图块被栅格化后，合成线程生成一个绘制图块的命令提交给浏览器进程，然后生成页面

#### 重排、重绘、合成

1. 重排

修改元素的几何属性会触发重排，会触发style（计算样式）后的所有流程，开销大

![image](https://pic1.zhimg.com/80/v2-88eb76703f5765c5889e44140ec549b8_1440w.jpg)

2. 重绘

修改元素的绘制属性会触发重绘，会跳过layout和layer阶段，性能好于重排

![image](https://pic2.zhimg.com/80/v2-146e92c0b2d807fe77f9e121deda4691_1440w.jpg)

3. 合成

使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作，性能最好

![image](https://pic1.zhimg.com/80/v2-62f789340c5d1882aff5f6e2e930bb58_1440w.jpg)

参考文档

1. [浏览器渲染流程](https://zhuanlan.zhihu.com/p/162722524)

#### q&a

##### load事件与DOMContentLoaded事件的先后

DOMContentLoaded是仅当DOM加载完成，而load是当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都加载完成才触发，故DOMContentLoaded在先

##### 加载css

css加载不会阻塞DOM树解析，但会阻塞render树渲染。如果css加载不阻塞render树渲染的话，那么当render树渲染完成后，又加载了一部分css，就会导致额外的重绘和重排

##### 普通图层和复合图层

浏览器渲染的图层一般包含两大类

- 普通图层

普通文档流、absolute布局都属于普通图层。absolute虽然可以脱离文档流，但仍属于普通图层，如果普通图层的内容过多，absolute改变过大，造成的资源损耗是比较严重的

- 复合图层

可以通过硬件加速的方式，声明一个复合图层，GPU中各个复合图层是单独绘制的，所以互不影响

使用复合图层可以独立于普通图层，可以跳过重排和重绘阶段，复合图层过多会消耗资源。一般采用以下方式可以硬件加速，变为复合图层

- translate3d、translateZ

- opacity属性/过渡动画（动画执行的过程中才会创建复合图层）

- will-chang属性

使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染，也就是说如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，造成不必要的资源损耗